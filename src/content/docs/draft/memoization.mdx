---
title: 메모이제이션
description: 메모이제이션을 사용하여 컴포넌트의 리렌더링을 최적화하는 방법을 알아봅니다.
---

메모이제이션 
함수를 또 생성하는걸 방지하기 위해 useCallback 사용
물론 useMemo로도 할수있음. 근데 얘한테 함수를 전달하면 그 함수가 실행되므로 콜백을 반환하는 함수를 만들어야함.
이 메모이제이션은 의존성배열 요소가 변경된 경우에만 새로 만듬.
사실 이런 최적화는 거의 필요하지 않음. 성능에 문제가 있거나, 함수 참조를 안정적으로 하는 경우에만 사용하기
특히 이펙트에서 커스텀훅 호출한다? 반드시 캐싱해야함. 커스텀훅은 컴포가 리렌더링 될 때마다 새로 생기기때문.
이펙트에서 커스텀훅 호출할땐 이펙트 종속성 배열에 커스텀훅이 들어갈건데 이게 계속 바뀌는거임.
그래서 커스텀훅은 useCallback으로 감싸는게 맞다.

리액트 메모이제이션은 useMemo, useCallback이 있음. 
메모이제이션의 이유는 크게 두가지임:
1. 비용이 많이 필요한 연산 피하기 (복잡한 연산을 가진 컴포넌트 재렌더링, 복잡한 연산을 가진 함수 호출 등)
2. 값 참조 안정성

2번은 주로 컴포넌트 내에서 만든 함수나 객체를 디펜던시 배열에 전달할 때 사용한다.
이 경우, 해당 함수나 객체는 컴포넌트 리렌더링에서 새로 생성되기 때문에 이펙트가 다시 실행되기 때문.
이걸 메모이제이션하면 컴포넌트 리렌더링에도 객체나 함수가 새로 생성되지 않고 기존 값을 사용한다.
객체를 메모하려면 useMemo, 함수를 메모하려면 useCallback을 사용하면 된다.
참고로 useMemo는 객체를 그대로 받는게 아니라 값을 반환하는 함수를 받음. 그래서 그걸 호출시킴.

팁: 먼저 의존성 배열에 있는 값을 정의하는 코드가 useEffect안으로 넣어도 되는지 확인한다.
안되면 메모이제이션하고, 의존성 배열에 추가
되면 useEffect 안으로 해당 값을 이동하고, 의존성 배열에서 그걸 제거한다.

참고할건 종속성 배열의 반응형 값이 변경될 때만 새로운 값을 반환한다는거.

모든 함수를 useCallback으로 감싸는건 좋지 않아요.
모든 라인의 코드는 실행 시 비용이 필요합니다.

useCallback을 사용하면 함수를 정의하고, 프로퍼티를 설정하고, 비교 연산을 수행하고, 배열을 정의하고.. 할 일이 매우 많음.

memo라는것도있음. 얘는 컴포넌트 정의를 감싼다. 그러면 캐싱된다. 그러면 언제 호출되나? props가 바뀔때 호출됨.
다른 요인에 의해 특정 컴포넌트가 렌더링됨을 방지하기 위해 사용할 수 있다.
다음 상황이 만족될 때만 사용하기
1. 동일한 props로 컴포넌트가 자주 리렌더링 됨 (계속 다른 props가 전달되는 경우에는 X)
2. 리렌더링 로직 비용이 많이 듬
3. 컴포넌트 리렌더링에 시간이 걸림

