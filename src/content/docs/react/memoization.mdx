---
title: 메모이제이션
description: 메모이제이션을 사용하여 컴포넌트의 리렌더링을 최적화하는 방법을 알아봅니다.
---

React에서 메모이제이션을 하는 이유는 크게 두 가지로 나눌 수 있습니다.

- 고비용 연산 (복잡한 연산을 가진 컴포넌트 재렌더링, 복잡한 연산을 가진 함수 호출 등)을 피하기 위해
- 값 참조의 안정성을 보장하기 위해 (함수나 객체의 경우)

import { Aside } from '@astrojs/starlight/components';

<Aside type="caution" title="사용 시기">
사실 이런 최적화는 거의 필요하지 않습니다. 눈에 띄는 성능 문제가 발생하거나, 함수나 객체를 안정적으로 참조해야 하는 경우에만 사용하세요.
</Aside>

React에서 값을 메모하는 방법은 세 가지가 있습니다.

- [useMemo](https:/react.dev/reference/react/useMemo)
- [useCallback](https:/react.dev/reference/react/useCallback)
- [memo](https:/react.dev/reference/react/memo)

## useMemo

값을 메모하기 위해 사용할 수 있는 훅입니다.

- 첫 번째 인자로 메모할 값을 반환하는 함수를 전달받습니다.
- 두 번째 인자로 종속성 배열을 전달받습니다. 이 배열에 포함된 값이 변경되면 함수가 새로운 값을 반환합니다.

```tsx
const memoizedValue = useMemo(() => expensiveComputation(a, b), [a, b]);
```

## useCallback

함수를 메모하기 위해 사용할 수 있는 훅입니다.

- 첫 번째 인자로 메모할 함수를 전달받습니다.
- 두 번째 인자로 종속성 배열을 전달받습니다. 이 배열에 포함된 값이 변경되면 새로운 함수를 반환합니다.

```tsx
const memoizedCallback = useCallback((a, b) => a + b, []);
```

## memo

컴포넌트를 메모하기 위해 사용되는 함수입니다. 반환된 컴포넌트는 부모 컴포넌트가 재렌더링되어도, 해당 컴포넌트의 props가 변하지 않았다면 재렌더링 되지 않습니다.

즉, 의존성 배열 대신 props를 비교하여 컴포넌트의 재렌더링 여부를 확인합니다.

```tsx
const MemoizedComponent = memo(function MyComponent(props) {
  return <div>{props.text}</div>;
});

function ParentComponent() {
  return <MemoizedComponent text="Hello, memo!" />;
}
```

이 함수는 다음과 같은 경우에 사용하는 것을 권장합니다.

- 컴포넌트가 동일한 props를 사용하여 재렌더링되는 경우가 많으면 사용하기 좋습니다.
    <Aside type="caution" title="주의">
    props가 자주 변경되는 경우에는 메모의 이점이 사라집니다.
    </Aside>
- 컴포넌트의 렌더링 비용이 높은 경우 (오래 걸리는 연산 등) 사용하기 좋습니다.

## 제한 사항

모든 값을 이러한 함수로 메모하는 것은 좋지 않습니다.

모든 라인의 코드는 실행 시 비용이 필요합니다. 메모이제이션을 수행하면 함수를 정의하고, 프로퍼티를 설정하고, 비교 연산을 수행하고, 배열을 정의하고, ... 다양한 작업이 추가됩니다.
